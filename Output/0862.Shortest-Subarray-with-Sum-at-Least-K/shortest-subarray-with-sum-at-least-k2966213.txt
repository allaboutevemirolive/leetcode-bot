// https://leetcode.com/problems/shortest-subarray-with-sum-at-least-k/solutions/2966213/just-a-runnable-solution/
impl Solution {
    pub fn shortest_subarray(nums: Vec<i32>, k: i32) -> i32 {
        fn _shortest_subarray(nums: Vec<i64>, k: i64) -> i64 {
            use std::collections::VecDeque;
            use std::i64::MAX;

            let mut ans = MAX;
            let mut queue: VecDeque<(i64, i64)> = VecDeque::new();
            queue.push_back((-1, 0));
            let mut prefix = 0;
            for (i, x) in nums.iter().enumerate() {
                prefix += x;
                while !queue.is_empty() && prefix - queue[0].1 >= k {
                    ans = ans.min(i as i64 - queue[0].0);
                    queue.pop_front();
                }

                while !queue.is_empty() && queue[queue.len() - 1].1 >= prefix {
                    queue.pop_back();
                }

                queue.push_back((i as i64, prefix));
            }
            if ans == MAX {
                -1
            } else {
                ans
            }
        }
        _shortest_subarray(nums.iter().map(|x| *x as i64).collect(), k as i64) as i32
    }
}