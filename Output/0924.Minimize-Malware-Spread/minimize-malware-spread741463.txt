// https://leetcode.com/problems/minimize-malware-spread/solutions/741463/rust-copied-and-bug-fixed/
// Copied and fixed from https://leetcode.com/problems/minimize-malware-spread/discuss/222033/Union-find-in-Rust
struct UnionFind {
    parents: Vec<usize>,
}

impl UnionFind {
    fn new(size: usize) -> UnionFind {
        UnionFind {
            parents: (0..size).collect(),
        }
    }

    fn union(&mut self, x: usize, y: usize) {
        let (px, py) = (self.find(x), self.find(y));
        // if px != py {
        self.parents[px] = py;
        // }
    }

    fn find(&mut self, x: usize) -> usize {
        let mut x = x;
        while x != self.parents[x] {
            x = self.parents[x];
        }
        x
        // if x != self.parents[x] {
        //     self.parents[x] = self.find(self.parents[x]);
        // }
        // self.parents[x]
    }
}

impl Solution {
    pub fn min_malware_spread(graph: Vec<Vec<i32>>, initial: Vec<i32>) -> i32 {
        let n = graph.len();
        let mut uf = UnionFind::new(n);
        for i in 0..n {
            for j in (i + 1)..n {
                if graph[i][j] == 1 {
                    uf.union(i, j);
                }
            }
        }
        let mut area = vec![0; graph.len()];
        // (0..graph.len()).for_each(|node| area[components.find(node)] += 1);
        // *initial
        //     .iter()
        //     .map(|p0| (-area[components.find(*p0 as usize)], p0))
        //     .min()
        //     .unwrap()
        //     .1
        let mut malware = vec![0; graph.len()];
        for i in 0..n {
            area[uf.find(i)] += 1
        }
        for &i in &initial {
            malware[uf.find(i as usize)] += 1;
        }
        let mut save = 0;
        let mut ans = std::i32::MAX;
        for &i in &initial {
            if i < ans {
                ans = i
            }
        }
        for i in initial {
            if malware[uf.find(i as usize)] == 1 {
                if area[uf.find(i as usize)] > save {
                    save = area[uf.find(i as usize)];
                    ans = i;
                } else if area[uf.find(i as usize)] == save {
                    ans = std::cmp::min(ans, i)
                }
            }
        }
        ans
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_min_malware_spread() {
        let graph = vec![vec![1, 1, 0], vec![1, 1, 0], vec![0, 0, 1]];
        let initial = vec![0, 1];
        assert_eq!(Solution::min_malware_spread(graph, initial), 0)
    }

    #[test]
    fn test_min_malware_spread_02() {
        let graph = vec![vec![1, 0, 0], vec![0, 1, 0], vec![0, 0, 1]];
        let initial = vec![0, 2];
        assert_eq!(Solution::min_malware_spread(graph, initial), 0)
    }

    #[test]
    fn test_min_malware_spread_03() {
        let graph = vec![vec![1, 1, 1], vec![1, 1, 1], vec![1, 1, 1]];
        let initial = vec![1, 2];
        assert_eq!(Solution::min_malware_spread(graph, initial), 1)
    }

    #[test]
    fn test_min_malware_spread_04() {
        let graph = vec![vec![1, 1, 0], vec![1, 1, 0], vec![0, 0, 1]];
        let initial = vec![0, 1, 2];
        assert_eq!(Solution::min_malware_spread(graph, initial), 2)
    }
}