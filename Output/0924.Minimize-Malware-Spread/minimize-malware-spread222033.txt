// https://leetcode.com/problems/minimize-malware-spread/solutions/222033/union-find-in-rust/
struct UnionFind {
    parents: Vec<usize>,
}

impl UnionFind {
    fn new(size: usize) -> UnionFind {
        UnionFind { parents: (0..size).collect() }
    }
    
    fn union(&mut self, x: usize, y: usize) {
        let (p_x, p_y) = (self.find(x), self.find(y));
        if p_x != p_y {
            self.parents[p_x] = p_y;
        }
    }
    
    fn find(&self, x: usize) -> usize {
        let mut x = x;
        while x != self.parents[x] {
            x = self.parents[x];
        }
        x
    }
}

impl Solution {
    pub fn min_malware_spread(graph: Vec<Vec<i32>>, initial: Vec<i32>) -> i32 {
        let mut components = UnionFind::new(graph.len());
        for i in 0..graph.len() {
            for j in (i+1)..graph.len() {
                if graph[i][j] == 1 {
                    components.union(i, j);
                }
            }
        }
        let mut areas = vec![0; graph.len()];
        (0..graph.len()).for_each(|node| areas[components.find(node)] += 1);
        *initial.iter().map(|p0| (-areas[components.find(*p0 as usize)], p0)).min().unwrap().1
    }
}