// https://leetcode.com/problems/minimize-malware-spread/solutions/2652498/rust-union-find-with-comments/
use std::cmp::Ordering;

struct UnionFind {
    parents: Vec<usize>,
    ranks: Vec<usize>,
}

impl UnionFind {
    pub fn new(size: usize) -> Self {
        Self {
            parents: (0..size).collect(),
            ranks: vec![0; size],
        }
    }

    pub fn find(&mut self, key: usize) -> usize {
        if self.parents[key] == key {
            return key;
        }

        let parent = self.find(self.parents[key]);
        self.parents[key] = parent;
        parent
    }

    pub fn union(&mut self, x: usize, y: usize) -> bool {
        let px = self.find(x);
        let py = self.find(y);

        if px == py {
            return false;
        }

        let rx = self.ranks[px];
        let ry = self.ranks[py];

        match rx.cmp(&ry) {
            Ordering::Less => self.parents[px] = py,
            Ordering::Greater => self.parents[py] = px,
            Ordering::Equal => {
                self.parents[px] = py;
                self.ranks[py] += 1;
            }
        }

        true
    }
}

pub fn min_malware_spread(graph: Vec<Vec<i32>>, initial: Vec<i32>) -> i32 {
    let mut uf = UnionFind::new(graph.len());

    // Connect all linked nodes, similar to "number of islands"
    for r in 0..graph.len() {
        for c in 0..graph[r].len() {
            if graph[r][c] == 1 {
                uf.union(r, c);
            }
        }
    }

    // Find out the size of each group of connected nodes
    let mut group_size = vec![0; graph.len()];
    for node in 0..graph.len() {
        group_size[uf.find(node)] += 1;
    }

    // Track how many initial nodes there are per group
    // because if there are more than one nodes, the whole
    // group will become infected regardless if we remove
    // one of the nodes.
    //
    // Therefore we need to find the largest group that has
    // exactly one initial node, because if we remove that node
    // then the whole group will be saved and avoid infection.
    //
    // If there are no such groups the we have to return the smallest
    // node id from the initial nodes
    let mut min_initial = initial[0];
    let mut infected_per_group = vec![0; graph.len()];
    for &node in initial.iter() {
        infected_per_group[uf.find(node as usize)] += 1;
        min_initial = node.min(min_initial);
    }

    let mut selected = min_initial;
    let mut largest_group_size = 0;

    // Process again all initially infected nodes
    for &node in initial.iter() {
        // Find the root of the group that will be infected by this node
        let group_id = uf.find(node as usize);

        // Consider the node only if there aren't any other infected
        // nodes belonging to this group, because if there are, the group
        // will be infected regardless of whether we remove this node, thus
        // we will minimize the infection if and only if this is the only
        // infected node in the group
        if infected_per_group[group_id] == 1 {
            if group_size[group_id] > largest_group_size {
                // find the largest group
                largest_group_size = group_size[group_id];
                selected = node;
            } else if group_size[group_id] == largest_group_size {
                // in case there are multiple groups with the same size
                // select the one with smaller initially infected node number
                selected = selected.min(node);
            }
        }
    }

    selected
}