// https://leetcode.com/problems/lfu-cache/solutions/2858800/just-a-runnable-solution/
use std::collections::HashMap;

struct LFUCache {
    capacity: usize,
    min_freq: usize,
    freq: HashMap<usize, Vec<usize>>,
    key_to_val: HashMap<usize, usize>,
    key_to_freq: HashMap<usize, usize>,
}

impl LFUCache {
    fn new(capacity: i32) -> Self {
        LFUCache {
            capacity: capacity as usize,
            min_freq: 0,
            freq: HashMap::new(),
            key_to_val: HashMap::new(),
            key_to_freq: HashMap::new(),
        }
    }

    fn get(&mut self, key: i32) -> i32 {
        let key = key as usize;
        if !self.key_to_val.contains_key(&key) {
            return -1;
        }

        let freq = self.key_to_freq.get(&key).unwrap();
        self.freq.get_mut(freq).unwrap().retain(|&k| k != key);
        if self.freq.get(freq).unwrap().is_empty() {
            self.freq.remove(freq);
            if self.min_freq == *freq {
                self.min_freq += 1;
            }
        }

        let freq = freq + 1;
        self.freq.entry(freq).or_default().push(key);
        self.key_to_freq.insert(key, freq);

        *self.key_to_val.get(&key).unwrap() as i32
    }

    fn put(&mut self, key: i32, value: i32) {
        let key = key as usize;
        let value = value as usize;
        if self.capacity == 0 {
            return;
        }

        if let std::collections::hash_map::Entry::Occupied(mut e) = self.key_to_val.entry(key) {
            e.insert(value);
            self.get(key as i32);
            return;
        }

        if self.key_to_val.len() == self.capacity {
            let key = self.freq.get_mut(&self.min_freq).unwrap().remove(0);
            self.key_to_val.remove(&key);
            self.key_to_freq.remove(&key);
            if self.freq.get(&self.min_freq).unwrap().is_empty() {
                self.freq.remove(&self.min_freq);
            }
        }

        self.key_to_val.insert(key, value);
        self.key_to_freq.insert(key, 1);
        self.freq.entry(1).or_default().push(key);
        self.min_freq = 1;
    }
}