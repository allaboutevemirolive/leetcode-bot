// https://leetcode.com/problems/text-justification/solutions/3101643/the-code-is-self-explanatory/

struct Bucket{
    min_width : usize,
    words : Vec<String>,
}

impl Bucket {

    pub fn distribute_spaces(a : usize, b : usize) -> Vec<usize> {
        let mut return_vec = Vec::new();
        for _ in 0..b{
            return_vec.push(0);
        }
        for i in 0..a{
            let v = return_vec.get_mut(i % b);
            let v = v.unwrap();
            *(v)+=1;
        }
        return return_vec;
    }

    pub fn new() -> Bucket{
        return Bucket{
            min_width : 0,
            words : Vec::new(),
        };
    }

    // put string into bucket
    pub fn push(&mut self, word : String){
        // the bucket does not contain any string
        if self.words.len() == 0 {
            self.min_width += word.len();
        }
        else {
            self.min_width += 1 + word.len();
        }
        self.words.push(word);
    }

    pub fn get_min_width(&self) -> usize {
        return self.min_width;
    }
    
    pub fn into_string_line(self, max_width : usize, is_last_line : bool) -> String{
        let len_words = self.words.len();
        let total_spaces : usize = max_width - self.words.iter().map(|s| s.len()).sum::<usize>();
        let mut return_string = String::new();


        if len_words == 1{
            return_string.push_str(&self.words[0]);
            return_string.push_str(&" ".repeat(total_spaces));
            return return_string;
        }

        let mut spaces = Bucket::distribute_spaces(total_spaces,len_words - 1).into_iter();

        for (i, word) in self.words.iter().enumerate(){
            // push word into return_string
            return_string.push_str(word);

            // push spaces into return_string
            match is_last_line{
                true => {
                    // case for the last word of a bucket
                    if i == len_words - 1{
                        return_string.push_str(&" ".repeat(max_width - return_string.len()));
                    }
                    else{
                        return_string.push_str(" ");
                    }
                }
                false => {
                    // case for the last word of a bucket
                    if i != len_words - 1{
                        return_string.push_str( &" ".repeat(spaces.next().unwrap()));
                    }
                }
            }
        }

        return return_string;
    }
}


impl Solution {
    pub fn full_justify(words: Vec<String>, max_width: i32) -> Vec<String> {
        let mut buckets : Vec<Bucket> = Vec::new();

        let mut bucket = Bucket::new();
        for word in words.into_iter() {
            if bucket.get_min_width() == 0 {
                bucket.push(word);
            }
            else if word.len() + bucket.get_min_width() + 1 <= max_width as usize {
                bucket.push(word);
            }
            else{
                buckets.push(bucket);
                bucket = Bucket::new();
                bucket.push(word);
            }
        }
        buckets.push(bucket); // put the last bucket into vector


        let mut return_vec : Vec<String> = Vec::new();

        let bucket_size = buckets.len();
        for (i, bucket) in buckets.into_iter().enumerate(){
            return_vec.push(bucket.into_string_line(max_width as usize, i==bucket_size - 1));
        }

        return return_vec;
    }
}
