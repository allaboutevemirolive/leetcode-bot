// https://leetcode.com/problems/parse-lisp-expression/solutions/2907850/just-a-runnable-solution/
use std::collections::HashMap;
impl Solution {
    pub fn evaluate(expression: String) -> i32 {
        let mut variables = HashMap::new();
        Self::get_val(expression.as_str(), &mut variables)
    }

    fn get_val(expr: &str, variables: &mut HashMap<String, i32>) -> i32 {
        let type_ = Self::get_type(expr);
        if type_ == 1 {
            let tokens = Self::parse(expr);
            println!("{:?}", tokens);
            Self::_evaluate_(&tokens, variables)
        } else if type_ == 2 {
            *variables.get(expr).unwrap()
        } else {
            let mut val = 0;
            let mut sign = 1;
            for c in expr.chars() {
                if c == '-' {
                    sign = -1;
                } else {
                    val = (val * 10) + (c as i32 - '0' as i32);
                }
            }
            val * sign
        }
    }

    fn _evaluate_(tokens: &[String], variables: &HashMap<String, i32>) -> i32 {
        let mut variables = variables.clone();
        let return_val;
        if tokens[0] == "mult" {
            return_val = Self::get_val(&tokens[1], &mut variables) * Self::get_val(&tokens[2], &mut variables);
        } else if tokens[0] == "add" {
            return_val = Self::get_val(&tokens[1], &mut variables) + Self::get_val(&tokens[2], &mut variables);
        } else {
            for i in (1..tokens.len() - 1).step_by(2) {
                let v = Self::get_val(&tokens[i + 1], &mut variables);
                variables.insert(tokens[i].to_string(), v);
            }
            return_val = Self::get_val(tokens.last().unwrap(), &mut variables);
        }
        return_val
    }

    fn parse(expr: &str) -> Vec<String> {
        let mut cursor = 1;
        let mut start = 1;
        let mut tokens = Vec::new();
        while cursor < expr.len() {
            let c = expr.chars().nth(cursor).unwrap();
            if c == ' ' || c == ')' {
                tokens.push(expr[start..cursor].to_string());
                start = cursor + 1;
            } else if c == '(' {
                let mut open_parenthesis = 1;
                while open_parenthesis > 0 && cursor < expr.len() {
                    cursor += 1;
                    let c = expr.chars().nth(cursor).unwrap();
                    if c == '(' {
                        open_parenthesis += 1;
                    } else if c == ')' {
                        open_parenthesis -= 1;
                    }
                }
            }
            cursor += 1;
        }
        tokens
    }

    fn get_type(expr: &str) -> i32 {
        let begin = expr.chars().next().unwrap();
        if begin == '(' {
            1
        } else if ('a'..='z').contains(&begin) {
            2
        } else {
            3
        }
    }
}
