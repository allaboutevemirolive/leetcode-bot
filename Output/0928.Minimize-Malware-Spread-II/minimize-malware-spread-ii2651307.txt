// https://leetcode.com/problems/minimize-malware-spread-ii/solutions/2651307/rust-100-faster-100-memory-dfs/
use std::collections::HashSet;

impl Solution {
    fn dfs(
        start: i32,
        graph: &Vec<Vec<i32>>,
        visited: &mut HashSet<i32>,
        visited_count: &mut Vec<i32>,
        initial: &HashSet<i32>,
    ) {
        if !visited.contains(&start) {
            visited.insert(start);
            visited_count[start as usize] += 1;

            let row = &graph[start as usize];

            for (i, elem) in row.iter().enumerate() {
                if *elem != 0 && !initial.contains(&(i as i32)) {
                    Solution::dfs(i as i32, graph, visited, visited_count, initial);
                }
            }
        }
    }

    pub fn min_malware_spread(mut graph: Vec<Vec<i32>>, initial: Vec<i32>) -> i32 {
        let initial_set: HashSet<i32> = initial.iter().map(|i| *i).collect();
        let mut visited_count: Vec<i32> = vec![0; graph.len()];

        let mut result: Vec<(i32, HashSet<i32>)> = initial
            .iter()
            .map(|start| {
                let mut visited = HashSet::new();
                Solution::dfs(
                    *start,
                    &graph,
                    &mut visited,
                    &mut visited_count,
                    &initial_set,
                );
                (-start, visited)
            })
            .collect();

        result
            .iter()
            .map(|(i1, s1)| {
                (
                    i1,
                    s1.iter()
                        .filter(|elem| visited_count[**elem as usize] == 1)
                        .count(),
                )
            })
            .max_by(|(i1, t1), (i2, t2)| t1.cmp(t2).then(i1.cmp(i2)))
            .map_or_else(|| 0, |res| -*res.0)
    }
}