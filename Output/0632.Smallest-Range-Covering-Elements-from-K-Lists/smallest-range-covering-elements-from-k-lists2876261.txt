// https://leetcode.com/problems/smallest-range-covering-elements-from-k-lists/solutions/2876261/just-a-runnable-solution/
impl Solution {
    pub fn smallest_range(nums: Vec<Vec<i32>>) -> Vec<i32> {
        let mut ranges = Vec::new();
        for (i, v) in nums.iter().enumerate() {
            for n in v {
                ranges.push((*n, i));
            }
        }
        ranges.sort();
        let mut map = std::collections::HashMap::new();
        let mut start = 0;
        let mut end = 0;
        let mut min = std::i32::MAX;
        let mut min_start = 0;
        let mut min_end = 0;
        while end < ranges.len() {
            map.entry(ranges[end].1).and_modify(|e| *e += 1).or_insert(1);
            while map.len() == nums.len() && map[&ranges[start].1] > 1 {
                map.entry(ranges[start].1).and_modify(|e| *e -= 1);
                start += 1;
            }
            if map.len() == nums.len() && min > ranges[end].0 - ranges[start].0 {
                min = ranges[end].0 - ranges[start].0;
                min_start = ranges[start].0;
                min_end = ranges[end].0;
            }
            end += 1;
        }
        vec![min_start, min_end]
    }
}