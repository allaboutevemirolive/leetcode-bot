// https://leetcode.com/problems/regular-expression-matching/solutions/2255830/rust-invented-my-own-algorithm-not-very-good-but-it-was-fun/
impl Solution {
    pub fn is_match(s: String, p: String) -> bool {
        let s: Vec<u8> = s.into_bytes();
        let p = Regex::parse(p.into_bytes());
        Solution::is_match_go(s.as_slice(), p.as_slice())
    }
    
    fn is_match_go(s: &[u8], p: &[Regex]) -> bool {
        // Recursively check the string, one pattern at a time
        // I think worst case is O(s.len()^(num of * in p + 1))
        
        if s.len() == 0 {
            // When string is over, we should only have * remaining in the regex
            if p.len() == 0 {
                return true;
            } else {
                if let Regex::AnyMany | Regex::CharMany{..} = &p[0] {
                    return Solution::is_match_go(s, &p[1..]);
                } else {
                    return false;
                }
            }
        } else {
            // If string is not over yet, we check the first pattern in the regex
            
            // When regex is over but string is not, we didn't match
            if p.len() == 0 {
                return false;
            }
            
            match &p[0] {
                // Pattern is some characters, check the start of the string
                Regex::CharSeq{val} => {
                    if s.starts_with(val.as_slice()) {
                        return Solution::is_match_go(&s[val.len()..], &p[1..]);
                    } else {
                        return false;
                    }
                },
                // Pattern is repeating characters, check all possibilities (matching 0,1,2,...)
                Regex::CharMany{val} => {
                    // This breaks tail-call recursion
                    for i in 0..s.len()+1 {
                        let matched_tail = Solution::is_match_go(&s[i..], &p[1..]);
                        if matched_tail {
                            return true;
                        } else if (i < s.len()) && (s[i] != *val) {
                            return false;
                        }
                    }
                    return false;
                },
                Regex::Any => {
                    return Solution::is_match_go(&s[1..], &p[1..]);
                },
                Regex::AnyMany => {
                    // Same as for char*, but we don't need to check the character
                    for i in 0..s.len()+1 {
                        let matched_tail = Solution::is_match_go(&s[i..], &p[1..]);
                        if matched_tail {
                            return true;
                        }
                    }
                    return false;
                }
            }
        }
    }
}

#[derive(Debug)]
enum Regex {
    CharSeq {val: Vec<u8>},
    CharMany {val: u8},
    Any,
    AnyMany
}

impl Regex {
    fn parse(p: Vec<u8>) -> Vec<Regex> {
        let mut regex: Vec<Regex> = vec![];
        let mut i = 1;
        while i < p.len() {
            match p[i-1] {
                b'a'..=b'z' => {
                    if p[i] == b'*' {
                        regex.push(Regex::CharMany{val: p[i-1]});
                        i += 1;
                    } else if let Some(Regex::CharSeq{val}) = regex.last_mut() {
                        val.push(p[i-1]);
                    } else {
                        regex.push(Regex::CharSeq{val: vec![p[i-1]]});
                    }
                    i += 1;
                },
                b'.' => {
                    if p[i] == b'*' {
                        regex.push(Regex::AnyMany);
                        i += 2;
                    } else {
                        regex.push(Regex::Any);
                        i += 1;
                    }
                },
                _ => ()
            }
        }
        if i == p.len() {
            match p[i-1] {
                b'a'..=b'z' => {
                    if let Some(Regex::CharSeq{val}) = regex.last_mut() {
                        val.push(p[i-1]);
                    } else {
                        regex.push(Regex::CharSeq{val: vec![p[i-1]]});
                    }
                },
                b'.' => {regex.push(Regex::Any);},
                _    => ()
            }
        }
        regex
    }    
}