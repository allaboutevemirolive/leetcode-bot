// https://leetcode.com/problems/max-points-on-a-line/solutions/3016485/rust-solution-using-only-i32-s-reducing-fractions-and-hashmap/
#[derive(Hash, PartialEq, Eq)]
struct Eqn {
    grad: (i32, i32),
    cept: (i32, i32),
}

impl Eqn {
    fn from(a: &Vec<i32>, b: &Vec<i32>) -> Self {
        let m = reduce(a[1] - b[1], a[0] - b[0]);

        if m.1 == 0 {
            return Self {
                grad: m,
                cept: (a[0], 0),
            };
        }

        let cept = reduce(m.0 * a[0] + m.1 * a[1], m.1);

        Self {
            grad: m,
            cept: cept,
        }
    }
}

use std::collections::HashMap;

impl Solution {
    pub fn max_points(points: Vec<Vec<i32>>) -> i32 {
        let mut map = HashMap::with_capacity(300);
        let mut ans = 1;

        let n = points.len();

        for i in 0..n {
            map.clear();
            for j in 0..n {
                if j == i {
                    continue;
                }

                let eqn = Eqn::from(&points[i], &points[j]);

                match map.get_mut(&eqn) {
                    Some(v) => {
                        *v += 1;
                        ans = ans.max(*v);
                    }
                    None => {
                        map.insert(eqn, 2);
                        ans = ans.max(2);
                    }
                }
            }
        }

        ans
    }
}

fn gcd(a: i32, b: i32) -> i32 {
    if b == 0 {
        return a;
    }
    gcd(b, a % b)
}

fn reduce(a: i32, b: i32) -> (i32, i32) {
    let gcd = gcd(a, b);
    (a / gcd, b / gcd)
}
