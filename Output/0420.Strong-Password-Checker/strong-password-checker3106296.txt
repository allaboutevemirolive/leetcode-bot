// https://leetcode.com/problems/strong-password-checker/solutions/3106296/greedy-tailored/
use std::cmp::Reverse;

impl Solution {
    pub fn strong_password_checker(password: String) -> i32 {
        let mut password = password.chars().collect::<Vec<_>>();
        let mut add_len = 0;
        let mut sub_len = 0;
        if password.len() < 6 {
            add_len = 6 - password.len();
        } else if password.len() > 20 {
            sub_len = password.len() - 20;
        } 
        let (has_lower, has_upper, has_digit) = password.iter().fold((false,false,false), |(l,u,d),c| {
            match c {
                _ if c.is_lowercase() => (true, u,d),
                _ if c.is_uppercase() => (l,true,d),
                _ if c.is_digit(10) => (l,u,true),
                _ => (l,u,d)
            }
        });
        let mut prev = ' ';
        let mut cur = 0;
        let mut lens = std::collections::BinaryHeap::new();
        for c in password {
            if c == prev {
                cur += 1;
            } else {
                prev = c;
                if cur >= 3 {
                    lens.push((Reverse(cur % 3), cur));
                }
                cur = 1;
            }
        }
        if cur >= 3 { lens.push((Reverse(cur % 3), cur)); }
        for _ in 0..sub_len {
            if let Some((_,cur)) = lens.pop() {
                lens.push((Reverse((cur - 1) % 3), cur -1));
            }
        }
        let rep = lens.into_iter().map(|(_,cur)| cur / 3).sum();
        add_len.max(rep).max([has_lower, has_upper, has_digit].map(|v| if v {0_usize} else {1}).iter().sum()) as i32
        + sub_len as i32 
    }
}