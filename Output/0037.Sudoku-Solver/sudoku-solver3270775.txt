// https://leetcode.com/problems/sudoku-solver/solutions/3270775/rust-0ms-easy-to-follow-bitwise-ops/
impl Solution {
    pub fn solve_sudoku(board: &mut Vec<Vec<char>>) -> bool {
        let mut digits_row = [0b000000000; 9];
        let mut digits_col = [0b000000000; 9];
        let mut digits_cell = [0b000000000; 9];

        let mut solved = true;

        for (i, line) in board.iter().enumerate() {
            for (j, ch) in line.iter().enumerate() {
                // Digit in a single bit representation:
                // '1' => 0b000000001
                // '2' => 0b000000010
                // ...
                // '9' => 0b100000000
                let digit = match ch {
                    '.' => {
                        solved = false;
                        continue;
                    }
                    '1'..='9' => 1u16 << (*ch as u8 - b'0' - 1),
                    _ => panic!("Bad input"),
                };

                digits_col[j] ^= digit;
                digits_row[i] ^= digit;
                digits_cell[3 * (i / 3) + j / 3] ^= digit;
            }
        }

        if solved {
            return true;
        }

        let mut least_options_count = 9;
        let mut least_options = 0b111111111;
        let mut least_options_cell = (0usize, 0usize);

        for (i, line) in board.iter().enumerate() {
            for (j, &ch) in line.iter().enumerate() {
                if ch != '.' {
                    continue;
                }

                let digits = digits_col[j]
                    | digits_row[i]
                    | digits_cell[3 * (i / 3) + j / 3];

                let options_count = 9 - digits.count_ones();

                if options_count < least_options_count {
                    least_options_count = options_count;
                    least_options_cell = (i, j);
                    least_options = !digits;
                }
            }
        }

        for try_digit in (0..9).filter_map(|d| {
            if (1 << d) & least_options != 0 {
                Some(d + 1)
            } else {
                None
            }
        }) {
            board[least_options_cell.0][least_options_cell.1] =
                char::from(b'0' + try_digit);
            if Solution::solve_sudoku(board) {
                return true;
            }
        }

        board[least_options_cell.0][least_options_cell.1] = '.';
        false
    }
}