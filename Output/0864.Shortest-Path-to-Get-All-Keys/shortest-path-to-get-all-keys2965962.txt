// https://leetcode.com/problems/shortest-path-to-get-all-keys/solutions/2965962/just-a-runnable-solution/
impl Solution {
    pub fn shortest_path_all_keys(grid: Vec<String>) -> i32 {
        use std::collections::HashSet;
        let (mut q, _n, _m, mut ans, mut k) = (HashSet::new(), grid.len(), grid[0].len(), 0, 0);
        let (mut g, mut f) = ([[128; 32]; 32], [[[1000; 32]; 32]; 64]);
        for (i, x) in grid.iter().enumerate() {
            for (j, y) in x.chars().enumerate() {
                match y as u8 {
                    46 => {
                        g[i + 1][j + 1] = 0;
                    }
                    64 => {
                        g[i + 1][j + 1] = 0;
                        q.insert((i as u8 + 1, j as u8 + 1, 0u8));
                        f[0][i + 1][j + 1] = 0;
                    }
                    65..=71 => {
                        g[i + 1][j + 1] = 1 << (y as u32 - 65);
                    }
                    97..=103 => {
                        g[i + 1][j + 1] = 256 << (y as u32 - 97);
                        k += 1;
                    }
                    _ => {}
                }
            }
        }
        while !q.is_empty() {
            let mut tmp = HashSet::new();
            ans += 1;
            for (i, j, s) in q.into_iter().map(|x| (x.0 as usize, x.1 as usize, x.2 as usize)) {
                let ss: usize = s | (g[i + 1][j] >> 8);
                if ss.count_ones() as i32 == k {
                    return ans;
                }
                if g[i + 1][j] > 128 && f[ss][i + 1][j] > ans {
                    f[ss][i + 1][j] = ans;
                    tmp.insert((i as u8 + 1, j as u8, ss as u8));
                }
                if g[i + 1][j] < 256 && g[i + 1][j] & s == g[i + 1][j] && f[s][i + 1][j] > ans {
                    f[s][i + 1][j] = ans;
                    tmp.insert((i as u8 + 1, j as u8, s as u8));
                }
                let ss: usize = s | (g[i - 1][j] >> 8);
                if ss.count_ones() as i32 == k {
                    return ans;
                }
                if g[i - 1][j] > 128 && f[ss][i - 1][j] > ans {
                    f[ss][i - 1][j] = ans;
                    tmp.insert((i as u8 - 1, j as u8, ss as u8));
                }
                if g[i - 1][j] < 256 && g[i - 1][j] & s == g[i - 1][j] && f[s][i - 1][j] > ans {
                    f[s][i - 1][j] = ans;
                    tmp.insert((i as u8 - 1, j as u8, s as u8));
                }
                let ss: usize = s | (g[i][j + 1] >> 8);
                if ss.count_ones() as i32 == k {
                    return ans;
                }
                if g[i][j + 1] > 128 && f[ss][i][j + 1] > ans {
                    f[ss][i][j + 1] = ans;
                    tmp.insert((i as u8, j as u8 + 1, ss as u8));
                }
                if g[i][j + 1] < 256 && g[i][j + 1] & s == g[i][j + 1] && f[s][i][j + 1] > ans {
                    f[s][i][j + 1] = ans;
                    tmp.insert((i as u8, j as u8 + 1, s as u8));
                }
                let ss: usize = s | (g[i][j - 1] >> 8);
                if ss.count_ones() as i32 == k {
                    return ans;
                }
                if g[i][j - 1] > 128 && f[ss][i][j - 1] > ans {
                    f[ss][i][j - 1] = ans;
                    tmp.insert((i as u8, j as u8 - 1, ss as u8));
                }
                if g[i][j - 1] < 256 && g[i][j - 1] & s == g[i][j - 1] && f[s][i][j - 1] > ans {
                    f[s][i][j - 1] = ans;
                    tmp.insert((i as u8, j as u8 - 1, s as u8));
                }
            }
            q = tmp;
        }
        -1
    }
}