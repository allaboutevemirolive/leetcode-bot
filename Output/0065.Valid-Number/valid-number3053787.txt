// https://leetcode.com/problems/valid-number/solutions/3053787/implementation-of-deterministic-finite-automata/
use std::cell::RefCell;
use std::collections::HashMap;
use std::rc::Rc;

struct State {
    name: String,
    transitions: HashMap<char, Rc<RefCell<State>>>,
}

impl PartialEq for State{
    // Use name of a state as a unique identifier
    fn eq(&self, other: &Self) -> bool {
        return self.get_name() == other.get_name();
    }
}

impl State {
    pub fn new(name: String) -> State {
        return State {
            name,
            transitions: HashMap::new(),
        };
    }

    pub fn get_name(&self) -> &str {
        return &self.name;
    }

    pub fn change_state(&self, input: char) -> Option<Rc<RefCell<State>>> {
        return match self.transitions.get(&input) {
            None => None,
            Some(state) => Some(state.clone()),
        };
    }

    pub fn add_transition(&mut self, c: char, other_state: Rc<RefCell<State>>) {
        self.transitions.insert(c, other_state);
    }
}



impl Solution {
    fn is_number (s: String) -> bool{
        let s = &s;

        let init = Rc::new(RefCell::new(State::new("Init".to_string())));

        // State Sign('+'|'-') 1 (start symbol)
        let s_sign_1 = Rc::new(RefCell::new(State::new("Sign('+'|'-') 1".to_string())));
        init.borrow_mut().add_transition('+', s_sign_1.clone());
        init.borrow_mut().add_transition('-', s_sign_1.clone());

        // State Digits 1 (start symbol)
        let s_digits_1 = Rc::new(RefCell::new(State::new("Digits 1".to_string())));
        for c in '0'..='9'{
            init.borrow_mut().add_transition(c, s_digits_1.clone());
            s_sign_1.borrow_mut().add_transition(c, s_digits_1.clone());
            s_digits_1.borrow_mut().add_transition(c, s_digits_1.clone());
        }

        // State dot 1 (start symbol)
        let s_dot_1 = Rc::new(RefCell::new(State::new("Dot 1".to_string())));
        init.borrow_mut().add_transition('.', s_dot_1.clone());
        s_sign_1.borrow_mut().add_transition('.', s_dot_1.clone());

        // State dot 2 (mid symbol)
        let s_dot_2 = Rc::new(RefCell::new(State::new("Dot 2".to_string())));
        s_digits_1.borrow_mut().add_transition('.', s_dot_2.clone());


        // State Digits 2
        let s_digits_2 = Rc::new(RefCell::new(State::new("Digits 2".to_string())));
        for c in '0'..='9'{
            s_digits_2.borrow_mut().add_transition(c, s_digits_2.clone());
            s_dot_1.borrow_mut().add_transition(c, s_digits_2.clone());
            s_dot_2.borrow_mut().add_transition(c, s_digits_2.clone());
        }

        // State ('e'|'E')
        let s_e = Rc::new(RefCell::new(State::new("'e'|'E'".to_string())));
        for c in "eE".chars(){
            s_digits_1.borrow_mut().add_transition(c, s_e.clone());
            s_dot_2.borrow_mut().add_transition(c, s_e.clone());
            s_digits_2.borrow_mut().add_transition(c, s_e.clone());
        }

        // State Sign('+'|'-') 2
        let s_sign_2 = Rc::new(RefCell::new(State::new("Sign('+'|'-') 2".to_string())));
        s_e.borrow_mut().add_transition('+', s_sign_2.clone());
        s_e.borrow_mut().add_transition('-', s_sign_2.clone());

        // State Digits 3
        let s_digits_3 = Rc::new(RefCell::new(State::new("Digits 3".to_string())));
        for c in '0'..='9'{
            s_e.borrow_mut().add_transition(c, s_digits_3.clone());
            s_sign_2.borrow_mut().add_transition(c, s_digits_3.clone());
            s_digits_3.borrow_mut().add_transition(c, s_digits_3.clone());
        }

        let names_of_acceptance = [
            s_digits_1.clone(),
            s_digits_2.clone(),
            s_dot_2.clone(),
            s_digits_3.clone()
        ];

        // Token scanning
        let mut current_state = Some(init.clone());
        println!("s={s}");
        for c in s.chars() {

            if current_state.is_some() {
                println!("{:?}", (c, current_state.as_ref().unwrap().borrow().get_name() ));
                current_state = current_state.unwrap().borrow().change_state(c);
            }
        }

        return current_state.is_some() && names_of_acceptance.contains(&current_state.unwrap());
    }
}
