// https://leetcode.com/problems/reverse-pairs/solutions/2862833/just-a-runnable-solution/
impl Solution {
    pub fn reverse_pairs(nums: Vec<i32>) -> i32 {
        let nums = nums.iter().map(|&x| x as i64).collect::<Vec<_>>();
        Self::_reverse_pairs(&nums) as i32
    }

    pub fn _reverse_pairs(nums: &Vec<i64>) -> usize {
        let mut pairs = 0;
        let mut sort_nums = vec![nums[0]];
        for &item in nums.iter().skip(1) {
            pairs += sort_nums.len() - Self::binary_search_insert(&mut sort_nums, 2 * item, false);
            Self::binary_search_insert(&mut sort_nums, item, true);
        }
        pairs
    }

    fn binary_search_insert(nums: &mut Vec<i64>, val: i64, insert: bool) -> usize {
        let mut l = 0;
        let mut r = nums.len() as i64 - 1;
        while l <= r {
            let m = (l + r) >> 1;
            if nums[m as usize] > val {
                r = m - 1;
            } else {
                l = m + 1;
            }
        }
        if insert {
            nums.insert((r + 1) as usize, val);
        }
        (r + 1) as usize
    }
}