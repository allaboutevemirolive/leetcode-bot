// https://leetcode.com/problems/n-queens/solutions/2930060/rust-o-n-space-complexity-using-binary-logic-with-test-cases/
pub struct Solution;

pub struct BoardState {
    cols: u32,
    left_dia: u32,
    right_dia: u32,
    order: Vec<usize>,
}

impl BoardState {
    pub fn new() -> BoardState {
        BoardState {
            cols: 0,
            left_dia: 0,
            right_dia: 0,
            order: Vec::new(),
        }
    }

    /// Find the possible location for a new queen in the next row
    pub fn possible_columns(&self, n: usize) -> Vec<usize> {
        let mut possible_indexes = Vec::new();
        // OR all taken positions together
        let ored = self.cols | self.left_dia | self.right_dia;
        // Mask to check if a column is available
        let mut mask = 1;

        for i in 0..n {
            // If there is a 0 in the column, then a queen can be placed in that column
            if ored & mask == 0 {
                possible_indexes.push(i);
            }
            mask <<= 1;
        }

        possible_indexes
    }

    /// Add a queen to the column.
    /// NOTE: This does not check if a queen CAN be placed in that column, it just places the
    /// queen. Use [`Self::possible_columns()`] to find which columns are valid for a new queen
    pub fn add_column(&mut self, col: u8) {
        // Add queen to column
        self.cols |= 1 << col;

        // Add queen to left diagonal
        self.left_dia |= 1 << col;
        self.left_dia = self.left_dia.rotate_left(1);

        // Add queen to right diagonal
        self.right_dia |= 1 << col;
        self.right_dia = self.right_dia.rotate_right(1);

        self.order.push(col as usize);
    }

    /// Removes a queen from a column
    pub fn backtrace(&mut self, col: u8) {
        // Remove queen from column
        self.cols &= !(1 << col);

        // Remove queen from left diagonal
        self.left_dia = self.left_dia.rotate_right(1);
        self.left_dia &= !(1 << col);

        // Remove queen from right diagonal
        self.right_dia = self.right_dia.rotate_left(1);
        self.right_dia &= !(1 << col);

        self.order.pop();
    }

    /// Generates the string representation of a board state
    pub fn get_solution(&self, n: u8) -> Vec<String> {
        let mut solution = Vec::new();
        let mut queen = String::new();

        for _ in 0..n {
            queen.push('.');
        }

        for col in &self.order {
            let mut this_queen = queen.clone();
            this_queen.replace_range(col..&(col + 1), "Q");
            solution.push(this_queen);
        }

        solution
    }
}

impl Solution {
    pub fn solve_n_queens(n: i32) -> Vec<Vec<String>> {
        let mut solutions = Vec::new();
        let mut state = BoardState::new();

        Self::recursion(&mut state, 0, n as usize, &mut solutions);

        solutions
    }

    fn recursion(state: &mut BoardState, row: usize, n: usize, solutions: &mut Vec<Vec<String>>) {
        // Found solution
        if row == n {
            solutions.push(state.get_solution(n as u8));
            return;
        }
        // Try each column
        for &col in &state.possible_columns(n) {
            state.add_column(col as u8);
            Self::recursion(state, row + 1, n, solutions);
            state.backtrace(col as u8);
        }
    }
}