// https://leetcode.com/problems/word-ladder/solutions/3107335/hash-set-solution/
impl Solution {
    pub fn ladder_length(begin_word: String, end_word: String, word_list: Vec<String>) -> i32 {
        fn words_exchangable(a: &str, b: &str) -> bool {
            let a = a.as_bytes();
            let b = b.as_bytes();
            let len = a.len();
            if len != b.len() {
                return false;
            }
            let mut times = 0;
            for i in 0..len {
                if a[i] != b[i] {
                    times += 1;
                }
                if times > 1 {
                    return false;
                }
            }
            times == 1
        }

        use std::collections::{HashSet, VecDeque};
        let mut word_set: HashSet<String> = word_list.into_iter().collect();
        word_set.remove(&begin_word);
        if !word_set.contains(&end_word) {
            return 0;
        }
        let mut queue = VecDeque::new();
        queue.push_back(begin_word);
        let mut step = 1;
        while !queue.is_empty() {
            let size = queue.len();
            for _ in 0..size {
                let front = queue.pop_front().unwrap();
                let mut tmp = vec![];
                for w in word_set.iter() {
                    if words_exchangable(&front, w) {
                        if w == &end_word {
                            return step + 1;
                        }
                        tmp.push(w.clone());
                        queue.push_back(w.clone());
                    }
                }
                for w in tmp {
                    word_set.remove(&w);
                }
            }
            step += 1;
        }
        0
    }
}