// https://leetcode.com/problems/scramble-string/solutions/3341368/recursion-memoization-pruning/
impl Solution {
    pub fn is_scramble(s1: String, s2: String) -> bool {
        is_scrambled(&s1, &s2)
    }
}

use std::collections::HashMap;

pub fn is_scrambled(s1: &str, s2: &str) -> bool {
    if s1.len() != s2.len() {
        return false;
    }

    let mut cache = HashMap::new();

    is_scrambled_helper(s1, s2, &mut cache)
}

fn is_scrambled_helper(s1: &str, s2: &str, cache: &mut HashMap<String, bool>) -> bool {
    if s1 == s2 {
        return true;
    }

    if s1.len() <= 1 {
        return false;
    }

    if s2.len() <= 1 {
        return false;
    }

    // Pruning
    let s1_count: AlphabetCount = s1.as_bytes().into();
    let s2_count: AlphabetCount = s2.as_bytes().into();

    if s1_count != s2_count {
        return false;
    }

    // Memoize
    let key = format!("{s1}-{s2}");

    if let Some(&result) = cache.get(&key) {
        return result;
    }

    let n = s1.len();

    let mut result = false;

    for i in 1..s1.len() {
        let (s1x, s1y) = s1.split_at(i);
        let (s2x, s2y) = s2.split_at(i);

        if is_scrambled_helper(s1x, s2x, cache) && is_scrambled_helper(s1y, s2y, cache) {
            result = true;
            break;
        }

        let (s2x, s2y) = s2.split_at(n - i);

        if is_scrambled_helper(s1x, s2y, cache) && is_scrambled_helper(s1y, s2x, cache) {
            result = true;
            break;
        }
    }

    cache.insert(key, result);

    result
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_is_scrambled_1() {
        assert!(is_scrambled("great", "rgeat"));
    }

    #[test]
    fn test_is_scrambled_2() {
        assert!(!is_scrambled("abcde", "caebd"));
    }

    #[test]
    fn test_is_scrambled_3() {
        assert!(!is_scrambled("ccabcbabcbabbbbcbb", "bbbbabccccbbbabcba"));
    }

    #[test]
    fn test_is_scrambled_4() {
        assert!(!is_scrambled(
            "eebaacbcbcadaaedceaaacadccd",
            "eadcaacabaddaceacbceaabeccd"
        ));
    }
}

#[derive(Default, PartialEq, Eq)]
pub struct AlphabetCount([usize; 26], [usize; 26]); // lower and upper case

impl AlphabetCount {
    pub fn new() -> Self {
        Default::default()
    }

    pub fn len(&self) -> usize {
        self.0
            .iter()
            .chain(self.1.iter())
            .filter(|&x| *x > 0)
            .count()
    }

    pub fn is_empty(&self) -> bool {
        self.len() == 0
    }

    pub fn get(&self, k: &u8) -> usize {
        let bucket = self.get_bucket_ref(k);
        let idx = Self::idx(k);

        bucket[idx]
    }

    pub fn set(&mut self, k: &u8, v: usize) {
        let bucket = self.get_bucket_mut(k);
        let idx = Self::idx(k);

        bucket[idx] = v;
    }

    pub fn increment(&mut self, k: &u8) {
        let bucket = self.get_bucket_mut(k);
        let idx = Self::idx(k);

        bucket[idx] += 1;
    }

    pub fn decrement(&mut self, k: &u8) {
        if self.get(k) == 0 {
            return;
        }

        let bucket = self.get_bucket_mut(k);
        let idx = Self::idx(k);

        bucket[idx] -= 1;
    }

    pub fn contains(&self, k: &u8) -> bool {
        let bucket = self.get_bucket_ref(k);
        let idx = Self::idx(k);

        bucket[idx] > 0
    }

    fn get_bucket_ref(&self, k: &u8) -> &[usize; 26] {
        match *k {
            b'a'..=b'z' => &self.0,
            b'A'..=b'Z' => &self.1,
            _ => unreachable!(),
        }
    }

    fn get_bucket_mut(&mut self, k: &u8) -> &mut [usize; 26] {
        match *k {
            b'a'..=b'z' => &mut self.0,
            b'A'..=b'Z' => &mut self.1,
            _ => unreachable!(),
        }
    }

    fn idx(k: &u8) -> usize {
        match *k {
            b'a'..=b'z' => *k as usize - 'a' as usize,
            b'A'..=b'Z' => *k as usize - 'A' as usize,
            _ => unreachable!(),
        }
    }
}

impl From<&[u8]> for AlphabetCount {
    fn from(value: &[u8]) -> Self {
        let mut counts = AlphabetCount::new();

        for k in value {
            counts.increment(k);
        }

        counts
    }
}