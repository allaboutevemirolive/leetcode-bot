// https://leetcode.com/problems/word-ladder/solutions/1765599/rust-4-implementations-150ms-150ms-30ms-16ms/
use std::collections::VecDeque;

const NO_PATH_FOUND: i32 = 0;

pub fn ladder_length(begin_word: String, end_word: String, mut word_list: Vec<String>) -> i32 {
    let mut start = None;
    let mut end = None;

    // make sure that the word list contains the begin/end words
    // then find their indexes
    for (idx, word) in word_list.iter().enumerate() {
        if begin_word.eq(word) {
            start = Some(idx);
        }

        if end_word.eq(word) {
            end = Some(idx);
        }

        if start.is_some() && end.is_some() {
            break;
        }
    }

    if end.is_none() {
        return NO_PATH_FOUND;
    }

    if start.is_none() {
        word_list.push(begin_word);
        start = Some(word_list.len() - 1);
    }

    let start = start.unwrap();
    let end = end.unwrap();

    // Build the adjacency lists
    let mut graph = vec![vec![]; word_list.len()];
    for i in 0..word_list.len() {
        for j in i + 1..word_list.len() {
            if is_adjacent(&word_list[i], &word_list[j]) {
                graph[i].push(j);
                graph[j].push(i);
            }
        }
    }

    // Run a BFS search
    let mut visited = vec![false; word_list.len()];
    let mut queue = VecDeque::new();

    // dist=1, because we count the words, not the transitions:
    // "cat" -> "bat" => 2 words, 1 transition
    queue.push_back((start, 1));

    while let Some((idx, dist)) = queue.pop_front() {
        if visited[idx] {
            continue;
        }

        if idx == end {
            return dist;
        }

        visited[idx] = true;
        graph[idx]
            .iter()
            .copied()
            .filter(|&idx| !visited[idx])
            .for_each(|i| queue.push_back((i, dist + 1)));
    }

    NO_PATH_FOUND
}

fn is_adjacent(a: &str, b: &str) -> bool {
    let a = a.as_bytes();
    let b = b.as_bytes();
    assert_eq!(a.len(), b.len());

    let mut diffs = 0;
    for idx in 0..a.len() {
        if a[idx] != b[idx] {
            diffs += 1;
        }

        if diffs > 1 {
            break;
        }
    }

    diffs == 1
}