// https://leetcode.com/problems/sudoku-solver/solutions/450358/rust-0ms-solution-with-backtracking-and-bit-operation/
impl Solution {
    pub fn solve_sudoku(board: &mut Vec<Vec<char>>) {
        assert!(Self::solve(board, 0));
    }

    // Return true if this sudoku board can be solved.
    fn solve(board: &mut Vec<Vec<char>>, mut filled: usize) -> bool {
        // Find a cell and try all options.
        while filled < 81 && board[filled / 9][filled % 9] != '.' {
            filled += 1;
        }

        // If all cells are filled, return true
        // indicating the sudoku board if solved.
        if filled == 81 {
            return true;
        }

        let row = filled / 9;
        let col = filled % 9;

        // Get all feasible options.
        let mut options = Self::options_at(row, col, board);

        let mut option = 1;
        while options != 0 {
            // Try for each option.
            if options & 1 == 1 {
                board[row][col] = char::from(option + b'0');
                if Self::solve(board, filled + 1) {
                    return true;
                }
                board[row][col] = '.';
            }

            option += 1;
            options >>= 1;
        }

        false
    }

    fn options_at(row: usize, col: usize, board: &Vec<Vec<char>>) -> u32 {
        let mut bits = 0b111111111;
        for i in 0..9 {
            // Remove numbers exist in the same row.
            bits &= !(((board[row][i] != '.') as u32) << (board[row][i] as u8 - b'0' - 1));
            // Remove numbers exist in the same column.
            bits &= !(((board[i][col] != '.') as u32) << (board[i][col] as u8 - b'0' - 1));

            // Remove numbers exist in the same 3x3 box.
            let x = row / 3 * 3 + i / 3;
            let y = col / 3 * 3 + i % 3;
            bits &= !(((board[x][y] != '.') as u32) << (board[x][y] as u8 - b'0' - 1));
        }
        bits
    }
}