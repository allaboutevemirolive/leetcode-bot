// https://leetcode.com/problems/sudoku-solver/solutions/2044694/rust-simple-solution-using-backtracking-template-0ms-23mb/
struct Sudoku<'a> {
    board: &'a mut Vec<Vec<char>>,
    squares: [[usize;10];9],
    rows: [[usize; 10]; 9],
    cols: [[usize; 10]; 9]
}

impl<'a> Sudoku<'a> {
    pub fn new(board: &'a mut Vec<Vec<char>>) -> Self {
        let mut sudoku = Self{
            board,
            squares: [[0usize; 10]; 9],
            rows: [[0usize; 10]; 9],
            cols: [[0usize; 10]; 9],
        };
        
        for row in 0..9 {
            for col in 0..9 {
                if sudoku.board[row][col] != '.' {
                    sudoku.place(row,col,sudoku.board[row][col]);
                }
            }
        }
        return sudoku;
    }
    
    pub fn solve(&mut self, i: usize) -> bool {
        if i >= 81 {
            return true;
        }
        let (row,col) = (i / 9, i % 9);
        
        if self.board[row][col] != '.' {
            return self.solve(i+1);
        }
        
		// iterate all possible candidates.
        for digit in '1'..='9' {
            if self.is_valid(row,col,digit) {
			    // try this partial candidate solution
                self.place(row,col,digit);
				// given the candidate, explore further.
                if self.solve(i+1) {
                    return true;
                } 
                // backtrack
                self.reverse(row,col);
            }
        }
        return false;
    }
    
    pub fn is_valid(&self, row: usize, col: usize, digit: char) -> bool {
        let digit = digit as usize - '0' as usize;
        
        return self.squares[row/3*3 + col/3][digit] == 0 && self.rows[row][digit] == 0 && self.cols[col][digit] == 0;
    }
    
    pub fn place(&mut self, row: usize, col: usize, digit: char) {
        self.board[row][col] = digit;
        
        let digit = digit as usize - '0' as usize;
        
        self.squares[row/3*3 + col/3][digit] += 1;
        self.rows[row][digit] += 1;
        self.cols[col][digit] += 1;
    }
    
    pub fn reverse(&mut self, row: usize, col: usize) {        
        let digit = self.board[row][col] as usize - '0' as usize;
        
        self.squares[row/3*3 + col/3][digit] -= 1;
        self.rows[row][digit] -= 1;
        self.cols[col][digit] -= 1;
        
        self.board[row][col] = '.';
    }
}

impl Solution {
    pub fn solve_sudoku(board: &mut Vec<Vec<char>>) {
        let mut sudoku = Sudoku::new(board);
        
        sudoku.solve(0);
    }
}