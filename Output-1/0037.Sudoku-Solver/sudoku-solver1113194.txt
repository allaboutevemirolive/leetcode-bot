// https://leetcode.com/problems/sudoku-solver/solutions/1113194/accepted-rust-solution/
impl Solution {
    fn check_valid(board: &Vec<Vec<char>>, next_char:char, r: usize, row_len: usize, c: usize) -> bool {
        for i in 0..row_len {
            if board[i][c] == next_char {
                return false;
            }
            if board[r][i] == next_char {
                return false;
            }
            let start_r = 3*(r/3);
            let start_c = 3*(c/3);
            if board[start_r + i/3][start_c + i%3] == next_char {
                return false;
            }
        }
        true
    }
    fn increase(c: char) -> char {
        if c == '.' {
            '1'
        } else {
            if c != '9' {
                std::char::from_u32(c as u32 + 1).unwrap()
            } else {
                '.'
            }
        }
    }

    fn next_step(board: &Vec<Vec<char>>, mut r: usize, mut c: usize, col_len: usize) -> (bool, usize, usize) {
        while board[r][c] != '.' {
            c += 1;
            if c == col_len {
                r += 1;
                c = 0
            }
            if r == board.len() {
                return (true, r, c);
            }
        }
        (false, r, c)
    }

    pub fn solve_sudoku(board: &mut Vec<Vec<char>>) {
        let col_len = board.len();
        let row_len = board.get(0).unwrap_or(&Vec::<char>::new()).len();
        let mut pos = vec![];
        let (_, mut row, mut col) = Solution::next_step(board, 0, 0, col_len);
        pos.push((row, col));
        loop {
            let current = board[row][col];
            let next_current = Solution::increase(current);

            if next_current == '.' {
                board[row][col] = next_current;
                let prev_step = pos.pop().unwrap();
                row = prev_step.0;
                col = prev_step.1;
                continue;
            }
            let res = Solution::check_valid(board, next_current, row, row_len, col);
            board[row][col] = next_current;
            if res {
                pos.push((row, col));
                let next_step = Solution::next_step(board, row, col, col_len);
                if next_step.0 {
                    break
                }
                row = next_step.1;
                col = next_step.2;
            }
        }
    }
}