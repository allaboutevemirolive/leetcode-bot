// https://leetcode.com/problems/first-missing-positive/solutions/1145828/rust-0ms-faster-than-100/
use std::cmp::Reverse;
use std::collections::BinaryHeap;


impl Solution {
 
	 pub fn first_missing_positive(nums: Vec<i32>) -> i32 {
        let nums_over_zero: Vec<_> = nums.into_iter()
            .filter(|&x| x > 0)
            .map(Reverse)
            .collect();

        let mut heap = BinaryHeap::from(nums_over_zero); // O(n) to build heap, where n is numbe of positive #s

        let mut expect = 1;

        while let Some(Reverse(elem)) = heap.pop() { // each pop takes log2(n) ... average time will be propotional to n/2  * log2(n)
            if elem < expect {
                continue // we have duplicate
            }
            if expect != elem {
                return expect;
            }
            expect += 1;
        }

        expect
    }

}