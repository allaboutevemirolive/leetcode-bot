// https://leetcode.com/problems/first-missing-positive/solutions/1089782/rust-sort-solution/
impl Solution {
    pub fn first_missing_positive(nums: Vec<i32>) -> i32 {
        fn q_sort(nums: &mut [i32]) {
            if nums.len() <= 1 {
                return;
            }
            let (mut left, right, mid) = (0, nums.len() - 1, nums.len() / 2);
            nums.swap(mid, right);
            for i in 0..nums.len() {
                if nums[i] < nums[right] {
                    nums.swap(i, left);
                    left += 1;
                }
            }
            nums.swap(left, right);
            q_sort(&mut nums[..left]);
            q_sort(&mut nums[left + 1..]);
        }
        let mut nums = nums;
        q_sort(&mut nums);
        
        let mut count = 1;
        for (i, v) in nums.iter().enumerate() {
            if *v <= 0 || (i > 0 && nums[i] == nums[i - 1]) {
                continue;
            } else if count == *v {
                count += 1;
                continue;
            } else {
                return count
            }
        }
        count
    }
}