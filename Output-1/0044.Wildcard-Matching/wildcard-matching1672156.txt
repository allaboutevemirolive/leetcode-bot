// https://leetcode.com/problems/wildcard-matching/solutions/1672156/rust-memoization/
#[derive(Hash, Eq, PartialEq)]
struct Entry {
    i: usize,
    j: usize
}

use std::collections::HashMap;

impl Solution {
    fn memoize(S: &Vec<char>, P: &Vec<char>, s: usize, p: usize, 
        H: &mut HashMap<Entry, bool>) -> bool 
    {
        let entry = Entry{i: s, j: p};
        if let Some(result) = H.get(&entry) {
            return *result;
        }
        let result = Solution::check(S, P, s, p, H);
        H.insert(entry, result);
        
        result
    }
    
    fn check(S: &Vec<char>, P: &Vec<char>, s: usize, p: usize, 
        H: &mut HashMap<Entry, bool>) -> bool 
    {
        match (s == S.len(), p == P.len()) {
            (true, true)   => { return true; }
            (false, true)  => { 
                return P.len() > 0 && P[P.len()-1] == '*'; 
            }
            (true, false)  => { 
                return p == P.len()-1 && P[p] == '*'; 
            }
            (false, false) => {
                if s > S.len() {
                    return false;
                }
            }
        }
        match (S[s], P[p]) {
            (_, '?') => { 
                return Solution::memoize(S, P, s+1, p+1, H); 
            }
            (_, '*') => {
                for i in (0..S.len()).rev() {
                    if Solution::memoize(S, P, s+i, p+1, H) {
                        return true;
                    }   
                }
            }
            (sc, pc) => { 
                return sc == pc && 
                    Solution::memoize(S, P, s+1, p+1, H); 
            }
        }
        false
    }
    
    pub fn is_match(s: String, p: String) -> bool {
        let mut P: Vec<char> = Vec::new();
        for p in p.chars() {
            if (p == '*' && P.len() > 0 && 
                    P[P.len()-1] == '*') == false {
                P.push(p);
            }
        }  
        let S: Vec<char> = s.chars().collect();
        let mut H: HashMap<Entry, bool> = HashMap::new();
        
        return Solution::check(&S, &P, 0, 0, &mut H);
    }
}