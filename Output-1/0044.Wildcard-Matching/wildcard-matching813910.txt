// https://leetcode.com/problems/wildcard-matching/solutions/813910/4ms-2-1mb-rust-solution/
impl Solution {
    pub fn is_match(mut s: String, mut p: String) -> bool {
        let s: Vec<char> = s.drain(..).collect();
        let n = s.len();
        let mut curr: Vec<usize> = Vec::with_capacity(n + 1);
        let mut curr_wildcard: Option<usize> = None;
        let mut next: Vec<usize> = Vec::with_capacity(n + 1);
        curr.push(0);
        for c in p.drain(..) {
            if curr.is_empty() {
                return false;
            }
            match c {
                '*' => {
                    if !curr_wildcard.is_some() {
                        curr_wildcard = Some(curr[0]);
                    }
                },
                '?' => {
                    if let Some(first) = curr_wildcard {
                        if first == n {
                            return false;
                        }
                        curr_wildcard = Some(first + 1);
                    } else {
                        for i in curr.iter_mut() {
                            *i += 1;
                        }
                        if curr.last().unwrap() > &n {
                            curr.pop();
                        }
                        curr_wildcard = None;
                    }
                },
                _ => {
                    next.clear();
                    if let Some(first) = curr_wildcard {
                        for i in first..n {
                            if s[i] == c {
                                next.push(i + 1);
                            }
                        }
                    } else {
                        if curr.last() == Some(&n) {
                            curr.pop();
                        }
                        for &i in curr.iter() {
                            if s[i] == c {
                                next.push(i + 1);
                            }
                        }
                    }
                    std::mem::swap(&mut curr, &mut next);
                    curr_wildcard = None;
                }
            }
        }
        
        curr_wildcard.is_some() ||
        curr.last().map(|&x| x == n).unwrap_or(false)
    }
}