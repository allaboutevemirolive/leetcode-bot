// https://leetcode.com/problems/regular-expression-matching/solutions/2628888/100-0ms-depth-first-recursive-rust-solution/
#[derive(PartialEq, Eq, Debug)]
enum SpecificChar {
    Any(usize),
    Seq(Vec<u8>),
}
#[derive(PartialEq, Eq, Debug)]
struct SeqSpecificChar {
    seq: Vec<SpecificChar>,
    len: usize,
}
#[derive(PartialEq, Eq, Debug)]
enum CharSeq {
    AsteriskChar(u8),
    Seq(SeqSpecificChar),
}
#[inline(always)]
fn try_empty_specific_char_seq(
    specific_char_seq: Vec<u8>,
    mut char_seq: SeqSpecificChar,
) -> (Vec<u8>, SeqSpecificChar) {
    if specific_char_seq.len() > 0 {
        char_seq.len += specific_char_seq.len();
        char_seq.seq.push(SpecificChar::Seq(specific_char_seq));
        return (Vec::new(), char_seq);
    }
    return (specific_char_seq, char_seq);
}
#[inline(always)]
fn try_empty_n_any_char(
    mut n_any_char: usize,
    mut char_seq: SeqSpecificChar,
) -> (usize, SeqSpecificChar) {
    if n_any_char > 0 {
        char_seq.seq.push(SpecificChar::Any(n_any_char));
        char_seq.len += n_any_char;
        n_any_char = 0;
    }
    (n_any_char, char_seq)
}
fn split_pattern<'a>(p: String) -> Vec<CharSeq> {
    let mut result = Vec::new();
    let chars = p.into_bytes();
    let mut i = 0;
    let mut n_any_char = 0;
    let mut specific_char_seq: Vec<u8> = Vec::new();
    let mut char_seq = SeqSpecificChar {
        seq: Vec::new(),
        len: 0,
    };
    loop {
        if i >= chars.len() {
            char_seq = try_empty_specific_char_seq(specific_char_seq, char_seq).1;
            char_seq = try_empty_n_any_char(n_any_char, char_seq).1;
            if char_seq.len > 0 {
                result.push(CharSeq::Seq(char_seq));
            }
            return result;
        }
        let ch = chars[i];
        if i + 1 < chars.len() && chars[i + 1] == b'*' {
            let tmp1 = try_empty_specific_char_seq(specific_char_seq, char_seq);
            specific_char_seq = tmp1.0;
            char_seq = tmp1.1;
            let tmp2 = try_empty_n_any_char(n_any_char, char_seq);
            n_any_char = tmp2.0;
            char_seq = tmp2.1;
            if char_seq.len > 0 {
                result.push(CharSeq::Seq(char_seq));
                char_seq = SeqSpecificChar {
                    seq: Vec::new(),
                    len: 0,
                };
            }
            result.push(CharSeq::AsteriskChar(ch));
            i += 2;
        } else {
            match ch {
                b'.' => {
                    i += 1;
                    n_any_char += 1;
                    let tmp = try_empty_specific_char_seq(specific_char_seq, char_seq);
                    specific_char_seq = tmp.0;
                    char_seq = tmp.1;
                }
                _ => {
                    i += 1;
                    specific_char_seq.push(ch);
                    let tmp = try_empty_n_any_char(n_any_char, char_seq);
                    n_any_char = tmp.0;
                    char_seq = tmp.1;
                }
            }
        }
    }
}
fn match_char_seq(s: &[u8], char_seq: &SeqSpecificChar) -> bool {
    let mut i = 0;
    if s.len() < char_seq.len {
        return false;
    }
    for specific_char in char_seq.seq.iter() {
        match specific_char {
            SpecificChar::Any(n) => {
                i += n;
                if i > s.len() {
                    return false;
                }
            }
            SpecificChar::Seq(seq) => {
                if i + seq.len() > s.len() {
                    return false;
                }
                if &s[i..i + seq.len()] != seq {
                    return false;
                }
                i += seq.len();
            }
        }
    }
    i == s.len()
}


fn max_asterisk_match_len(ch: u8, s: &[u8]) -> usize {
    let mut i = 0;
    while i < s.len() && (s[i] == ch || ch == b'.') {
        i += 1;
    }
    i
}

fn depth_first_search(
    pattern: &Vec<CharSeq>,
    string: &[u8],
    mut string_pointer: usize,
    mut pattern_pointer: usize,
) -> bool {

    if pattern_pointer >= pattern.len() {
        return string_pointer == string.len();
    }
    match &pattern[pattern_pointer] {
        CharSeq::Seq(seq) => {
            if string_pointer + seq.len <= string.len() && match_char_seq(&string[string_pointer..string_pointer + seq.len], seq) {
                return depth_first_search(
                    pattern,
                    string,
                    string_pointer + seq.len,
                    pattern_pointer + 1,
                );
            } else {
                return false;
            }
        }
        CharSeq::AsteriskChar(ch) => {
            let max_match_len = max_asterisk_match_len(*ch, &string[string_pointer..]);
            for i in (0..=max_match_len).rev() {
                if depth_first_search(pattern, string, string_pointer + i, pattern_pointer + 1) {
                    return true;
                }
            }
        }
    }
    return false;
}

impl Solution {
    pub fn is_match(s: String, p: String) -> bool {
        let mut pattern = split_pattern(p);
        let mut string = s.into_bytes();
        let mut string_pointer = 0;
        let mut pattern_pointer = 0;
        // remove last item if it is CharSeq::Seq
        // so we can be sure it ends with asterisk
        if pattern.len() > 0 {
            let last_item = pattern.pop();
            match last_item {
                Some(CharSeq::Seq(seq)) => {
                    if seq.len > string.len()
                        || !match_char_seq(&string[string.len() - seq.len..], &seq)
                    {
                        return false;
                    }
                    string = string[..string.len() - seq.len].to_vec();
                }
                _ => {
                    pattern.push(last_item.unwrap());
                }
            }
        }
        return depth_first_search(&pattern, &string, string_pointer, pattern_pointer);
    }
}