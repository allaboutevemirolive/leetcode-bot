// https://leetcode.com/problems/regular-expression-matching/solutions/3284005/dfs-solution/
#[derive(Clone, Copy)]
enum Op {
    Ch(u8),
    ChRep(u8),
}

impl Solution {
    fn dfs(s: &[u8], p: &[Op]) -> bool {
        if let Some(&op) = p.first() {
            if let Some(&c0) = s.first() {
                match op {
                    Op::Ch(c) => {
                        if c == c0 || c == b'.' {
                            Self::dfs(&s[1..], &p[1..])
                        } else {
                            false
                        }
                    }
                    Op::ChRep(c) => {
                        if c == c0 || c == b'.' {
                            Self::dfs(&s[1..], &p[..])
                                || Self::dfs(&s[..], &p[1..])
                        } else {
                            Self::dfs(&s[..], &p[1..])
                        }
                    }
                }
            } else {
                p.iter().all(|op| matches!(op, Op::ChRep(_)))
            }
        } else {
            s.is_empty()
        }
    }

    fn parse_pat(p: &[u8]) -> Vec<Op> {
        let mut ret = vec![];
        let mut i = 0;
        while i < p.len() {
            match p[i] {
                ch@(b'a'..=b'z' | b'.') => {
                    if let Some(b'*') = p.get(i + 1) {
                        ret.push(Op::ChRep(ch))
                    } else {
                        ret.push(Op::Ch(ch))
                    }
                }
                _ => (),
            }
            i += 1;
        }
        ret
    }

    pub fn is_match(s: String, p: String) -> bool {
        let s = s.as_bytes();
        let p = Self::parse_pat(p.as_bytes());
        Self::dfs(s, &p)
    }
}