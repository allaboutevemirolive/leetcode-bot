// https://leetcode.com/problems/first-missing-positive/solutions/2430907/commented-rust-code-written-with-the-help-of-copilot/
impl Solution {
    pub fn first_missing_positive(mut nums: Vec<i32>) -> i32 {
        // first sweep
        let mut i = 0;
        // invariant: (nums[0..i])[j] = either j + 1 or -1
        // invariant: (nums[0..i])[j] = j + 1 if (nums_original[0..i]) contains j + 1
        while i < nums.len() {
            if nums[i] <= 0 {
                nums[i] = -1;
                i += 1;
                continue;
            }
            if nums[i] > nums.len() as i32{
                nums[i] = -1;
                i += 1;
                continue;
            }
            if nums[i] == i as i32 + 1{
                i += 1;
                continue;
            }
            if nums[i] < i as i32 + 1 {
                let x = nums[i];
                let y = nums[x as usize - 1];
                if y == -1 {
                    nums[x as usize - 1] = x;
                }
                // if y is not -1, then by the invariant,
                // it must be the case that y == x
                nums[i] = -1;
                i += 1;
                continue;
            }
            if nums[i] > i as i32 + 1 {
                let x = nums[i];
                let y = nums[x as usize - 1];
                // if this is a 2-cycle, then we need to move on
                if x == y {
                    nums[i] = -1;
                    i += 1;
                    continue;
                }
                nums[x as usize - 1] = x;
                nums[i] = y;
                // note that the first invariant may not be satisfied
                // hence the loop counter is not incremented
                continue;
            }
        }
        // at the end of the loop, i = nums.len()
        // thus, as a consequence of the invariants above,
        // nums[j] = j + 1 iff nums originally contained j + 1

        // second sweep
        // thus, the first j with nums[j] = -1 is the first missing positive
        match (0..nums.len()).find(|&i| nums[i as usize] == -1) {
            Some(i) => i as i32 + 1,
            None => nums.len() as i32 + 1,
        }
    }
}