// https://leetcode.com/problems/edit-distance/solutions/3233811/idiomatic-solution-using-recursion/
impl Solution {
    fn get_cost(word1: &[u8], word2: &[u8], dp: &mut Vec<Vec<u16>>) -> u16 {
        if word2.is_empty() {
            return word1.len() as u16; // delete remaining chars
        }
        if word1.is_empty() {
            return word2.len() as u16; // insert remaining chars
        }
        let answer = dp[word1.len() - 1][word2.len() - 1];
        if answer != u16::MAX {
            return answer;
        }

        if word1[0] == word2[0] {
            return Self::get_cost(&word1[1..], &word2[1..], dp); // use that letter
        }

        // insert or replace or delete
        let insert_cost = Self::get_cost(&word1[..], &word2[1..], dp);
        let replace_cost = Self::get_cost(&word1[1..], &word2[1..], dp);
        let delete_cost = Self::get_cost(&word1[1..], &word2[..], dp);

        let answer = insert_cost.min(replace_cost).min(delete_cost) + 1;
        dp[word1.len() - 1][word2.len() - 1] = answer;
        answer
    }
    pub fn min_distance(word1: String, word2: String) -> i32 {
        let word1 = word1.as_bytes();
        let word2 = word2.as_bytes();
        let mut dp = vec![vec![u16::MAX; word2.len()]; word1.len()];
        Self::get_cost(&word1[..], &word2, &mut dp) as i32
    }
}